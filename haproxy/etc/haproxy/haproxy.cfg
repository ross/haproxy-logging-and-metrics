# Things that are globally applied to all frontends/backends and the server itself.
global
  description "HAProxy Logging and Metrics Example Setup"

  user haproxy
  group haproxy
  pidfile /var/run/haproxy.pid


  # TODO: best practices for facility and level...
  log vector:514 len 65535 local0
  #log-send-hostname "what-you-want-it-to-be-default-is-full-hostname"
  #log-send-tag "what-you-want-it-to-be-default-is-haproxy"

  # Enable cipherlist capturing on connections so that we'll have access to that information if/when needed
  tune.ssl.capture-cipherlist-size 2048

defaults tcp-defaults
  mode tcp

  ## Logging

  log global
  #log-format TODO
  no option dontlognull
  option tcplog
  option log-health-checks
  option log-separate-errors

  ## Timeouts (required, not best practices)
  timeout client 10s
  timeout connect 10s
  timeout server 10s


frontend ssh

  bind 0.0.0.0:22 defer-accept

defaults http-defaults
  mode http

  log global
  # see https for details/notes
  log-format "backend_name=%b bytes_read=%B bytes_uploaded=%U client_ip=%ci client_port=%cp date_time=%t date_time_request=%tr fc_reordering=%[fc_reordering] fc_retrans=%[fc_retrans] fc_rtt=%[fc_rtt] fc_rttvar=%[fc_rttvar] frontend_ip=%fi frontend_name=%f frontend_port=%fp frontend_transport=%ft host_header=%{+Q,+E}[var(txn.host_header)] method=%HM path=%{+Q,+E}HP query=%{+Q,+E}HQ real_ip=%[var(txn.real_ip)] request_id=%[var(txn.request_id)] request_us=%[date(0,us)] retries=%rc server_name=%s status_code=%ST termination_state=%ts time_backend_connect=%Tc time_backend_response=%Tr time_connect=%Th time_idle=%Ti time_request=%TR time_response=%Ta time_total=%Tt time_user_est=%Tu time_waiting=%Tw version=%HV"
  no option dontlognull
  option log-health-checks
  option log-separate-errors

  ## Timeouts (required, not best practices)
  timeout client 10s
  timeout connect 10s
  timeout server 10s

frontend http

  # Listen on all ips port 80
  bind 0.0.0.0:80 defer-accept

  # Note: Logging related bits that have to live in the frontend. In more
  # complex setups this should generally be an "included" snippet
  http-request set-var(txn.host_header) req.hdr(host)

  # Note: this should check client_ip against a list/map of "internal" blocks
  # or otherwise verify that the request came from a source that we can trust
  # to be passing along a "real" request id for us to use.
  acl is_trusted always_true
  acl has_existing_request_id req.hdr(x-request-id) -m found
  # This value should be set by the first HAProxy that touches a request and
  # passed along (trusted) by any subsequent proxies.
  http-request set-header x-request-id %{+X}o\ %ci:%cp_%fi:%fp_%Ts_%rt:%pid if !is_trusted or !has_existing_request_id
  http-request set-var(txn.request_id) req.hdr(x-request-id)
  # We'll always add in the request-id as we see it to the response
  http-response set-header x-request-id %[var(txn.request_id)]
  # The "real" client ip, not just the previous proxy's
  acl has_existing_x_forwarded_for req.hdr(x-forwarded-for) -m found
  # TODO: this make sense?
  http-request set-header x-real-ip %[req.hdr(x-forwarded-for)] if has_existing_x_forwarded_for
  http-request set-header x-real-ip %ci if !has_existing_x_forwarded_for
  http-request set-var(txn.real_ip) req.hdr(x-real-ip)
  # option forwardfor will take care of adding/updating the request header

  # Redirect everything to https
  redirect scheme https code 301

defaults https-defaults
  mode http

  log global
  # Log formats: https://www.haproxy.com/documentation/hapee/latest/onepage/#8.2.4
  # Timing info: https://www.haproxy.com/documentation/hapee/latest/onepage/#8.4
  log-format "backend_name=%b bytes_read=%B bytes_uploaded=%U client_ip=%ci client_port=%cp date_time=%t date_time_request=%tr fc_reordering=%[fc_reordering] fc_retrans=%[fc_retrans] fc_rtt=%[fc_rtt] fc_rttvar=%[fc_rttvar] frontend_ip=%fi frontend_name=%f frontend_port=%fp frontend_transport=%ft host_header=%{+Q,+E}[var(txn.host_header)] method=%HM path=%{+Q,+E}HP query=%{+Q,+E}HQ real_ip=%[var(txn.real_ip)] request_id=%[var(txn.request_id)] request_us=%[date(0,us)] retries=%rc server_name=%s ssl_ciphers=%sslc ssl_version=%sslv status_code=%ST termination_state=%ts time_backend_connect=%Tc time_backend_response=%Tr time_connect=%Th time_idle=%Ti time_request=%TR time_response=%Ta time_total=%Tt time_user_est=%Tu time_waiting=%Tw version=%HV"
  no option dontlognull
  option log-health-checks
  option log-separate-errors

  option forwardfor

  ## Timeouts (required, not best practices)
  timeout client 10s
  timeout connect 10s
  timeout server 10s

  # TODO: health checks

  default_backend 200_ok

frontend https

  # Note: Logging related bits that have to live in the frontend. In more
  # complex setups this should generally be an "included" snippet
  http-request set-var(txn.host_header) req.hdr(host)

  # Note: this should check client_ip against a list/map of "internal" blocks
  # or otherwise verify that the request came from a source that we can trust
  # to be passing along a "real" request id for us to use.
  acl is_trusted always_true
  acl has_existing_request_id req.hdr(x-request-id) -m found
  # This value should be set by the first HAProxy that touches a request and
  # passed along (trusted) by any subsequent proxies.
  http-request set-header x-request-id %{+X}o\ %ci:%cp_%fi:%fp_%Ts_%rt:%pid if !is_trusted or !has_existing_request_id
  http-request set-var(txn.request_id) req.hdr(x-request-id)
  # We'll always add in the request-id as we see it to the response
  http-response set-header x-request-id %[var(txn.request_id)]
  # The "real" client ip, not just the previous proxy's
  acl has_existing_x_forwarded_for req.hdr(x-forwarded-for) -m found
  # TODO: this make sense?
  http-request set-header x-real-ip %[req.hdr(x-forwarded-for)] if has_existing_x_forwarded_for
  http-request set-header x-real-ip %ci if !has_existing_x_forwarded_for
  http-request set-var(txn.real_ip) req.hdr(x-real-ip)
  # option forwardfor will take care of adding/updating the request header

  # TODO: TLS
  bind 0.0.0.0:443 defer-accept

backend 200_ok
  errorfile 200 errors/200_ok.http
  http-request deny deny_status 200
