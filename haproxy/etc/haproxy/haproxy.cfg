# Things that are globally applied to all frontends/backends and the server itself.
global
  description "HAProxy Logging and Metrics Example Setup"

  user haproxy
  group haproxy
  pidfile /var/run/haproxy.pid

  log vector:514 len 65535 local0
  #log-send-hostname "what-you-want-it-to-be-default-is-full-hostname"
  #log-send-tag "what-you-want-it-to-be-default-is-haproxy"

  # Enable cipherlist capturing on connections so that we'll have access to that information if/when needed
  tune.ssl.capture-cipherlist-size 2048

defaults tcp-defaults
  mode tcp

  ## Logging

  log global
  log-format "backend_name=%b bytes_rx=%U bytes_tx=%B client_ip=%ci client_port=%cp fc_reordering=%[fc_reordering] fc_retrans=%[fc_retrans] fc_rtt=%[fc_rtt] fc_rttvar=%[fc_rttvar] frontend_ip=%fi frontend_name=%f frontend_port=%fp frontend_transport=%ft retries=%rc server_name=%s termination_state=%ts time_backend_connect=%Tc time_connect=%Th request_time_start=%[date(0,us)] time_total=%Tt time_waiting=%Tw"
  no option dontlognull
  option log-health-checks
  option log-separate-errors

  ## Timeouts (required, not best practices)
  timeout client 10s
  timeout connect 10s
  timeout server 10s

frontend ssh

  bind *:22

  tcp-request content reject

defaults http-defaults
  mode http

  log global
  # see https for details/notes
  log-format "backend_name=%b bytes_rx=%U bytes_tx=%B client_ip=%ci client_port=%cp fc_reordering=%[fc_reordering] fc_retrans=%[fc_retrans] fc_rtt=%[fc_rtt] fc_rttvar=%[fc_rttvar] frontend_ip=%fi frontend_name=%f frontend_port=%fp frontend_transport=%ft host_header=%{+Q,+E}[var(txn.host_header)] method=%HM path=%{+Q,+E}HP query=%{+Q,+E}HQ real_ip=%[var(txn.real_ip)] request_id=%[var(txn.request_id)] retries=%rc server_name=%s status_code=%ST termination_state=%ts time_backend_connect=%Tc time_backend_response=%Tr time_connect=%Th time_idle=%Ti time_request=%TR time_response=%Ta time_Start=%[date(0,us)] time_total=%Tt time_user_est=%Tu time_waiting=%Tw user_agent=%{+Q,+E}[var(txn.user_agent)] version=%HV"
  no option dontlognull
  option log-health-checks
  option log-separate-errors

  ## Timeouts (required, not best practices)
  timeout client 10s
  timeout connect 10s
  timeout server 10s

frontend http

  # Listen on all ips port 80
  bind *:80

  # see https for details/notes
  capture request header Host len 80
  http-request set-var(txn.host_header) capture.req.hdr(0)
  capture request header User-Agent len 100
  http-request set-var(txn.user_agent) capture.req.hdr(1)
  acl is_trusted always_true
  acl has_existing_request_id req.hdr(x-request-id) -m found
  http-request set-header x-request-id %{+X}o\ %ci:%cp_%fi:%fp_%Ts_%rt:%pid if !is_trusted or !has_existing_request_id
  http-request set-var(txn.request_id) req.hdr(x-request-id)
  http-response set-header x-request-id %[var(txn.request_id)]
  acl has_existing_x_forwarded_for req.hdr(x-forwarded-for) -m found
  http-request set-header x-real-ip %[req.hdr(x-forwarded-for,1)] if has_existing_x_forwarded_for
  http-request set-header x-real-ip %ci if !has_existing_x_forwarded_for
  http-request set-var(txn.real_ip) req.hdr(x-real-ip)

  # Redirect everything to https
  redirect scheme https code 301

defaults https-defaults
  mode http

  log global
  # Log formats: https://www.haproxy.com/documentation/hapee/latest/onepage/#8.2.4
  # Timing info: https://www.haproxy.com/documentation/hapee/latest/onepage/#8.4
  log-format "backend_name=%b bytes_rx=%U bytes_tx=%B client_ip=%ci client_port=%cp fc_reordering=%[fc_reordering] fc_retrans=%[fc_retrans] fc_rtt=%[fc_rtt] fc_rttvar=%[fc_rttvar] frontend_ip=%fi frontend_name=%f frontend_port=%fp frontend_transport=%ft host_header=%{+Q,+E}[var(txn.host_header)] method=%HM path=%{+Q,+E}HP query=%{+Q,+E}HQ real_ip=%[var(txn.real_ip)] request_id=%[var(txn.request_id)] retries=%rc server_name=%s ssl_ciphers=%sslc ssl_version=%sslv status_code=%ST termination_state=%ts time_backend_connect=%Tc time_backend_response=%Tr time_connect=%Th time_idle=%Ti time_request=%TR time_response=%Ta time_start=%[date(0,us)] time_total=%Tt time_user_est=%Tu time_waiting=%Tw user_agent=%{+Q,+E}[var(txn.user_agent)] version=%HV"
  no option dontlognull
  option log-health-checks
  option log-separate-errors

  option forwardfor

  ## Timeouts (required, not best practices)
  timeout client 10s
  timeout connect 10s
  timeout server 10s

  default_backend 200_ok

frontend https

  bind *:443 ssl crt /etc/haproxy/ssl/server.pem

  # Note: Logging related bits that have to live in the frontend. In more
  # complex setups this should generally be an "included" snippet

  # Messing with captures is annoying since they're indexed and not named, only
  # reason they're being used here is to truncate these fields and to avoid
  # allowing clients to "stuff" our logs with huge values. We'll immediately
  # copy the results into a var so that it can be used in acl's and/or logged
  # without referring to the index everywhere which should be safer.
  capture request header Host len 80
  http-request set-var(txn.host_header) capture.req.hdr(0)
  capture request header User-Agent len 100
  http-request set-var(txn.user_agent) capture.req.hdr(1)

  # Note: this should check client_ip against a list/map of "internal" blocks
  # or otherwise verify that the request came from a source that we can trust
  # to be passing along a "real" request id for us to use.
  acl is_trusted always_true
  acl has_existing_request_id req.hdr(x-request-id) -m found
  # This value should be set by the first HAProxy that touches a request and
  # passed along (trusted) by any subsequent proxies.
  http-request set-header x-request-id %{+X}o\ %ci:%cp_%fi:%fp_%Ts_%rt:%pid if !is_trusted or !has_existing_request_id
  http-request set-var(txn.request_id) req.hdr(x-request-id)
  # We'll always add in the request-id as we see it to the response
  http-response set-header x-request-id %[var(txn.request_id)]
  # The "real" client ip, not just the previous proxy's
  acl has_existing_x_forwarded_for req.hdr(x-forwarded-for) -m found
  # First IP in x-forwarded-for is client's real ip
  http-request set-header x-real-ip %[req.hdr(x-forwarded-for,1)] if has_existing_x_forwarded_for
  # If we don't have x-forwarded-for then just use client_ip
  http-request set-header x-real-ip %ci if !has_existing_x_forwarded_for
  http-request set-var(txn.real_ip) req.hdr(x-real-ip)
  # option forwardfor will take care of adding/updating the request header

  acl path_httpbin path_beg -i /httpbin/
  use_backend httpbin if path_httpbin

backend 200_ok
  errorfile 200 errors/200_ok.http
  http-request deny deny_status 200

backend httpbin

  option httpchk
  http-check send meth GET uri /httpbin/status/200 ver HTTP/1.1 hdr Host nghttp2.org hdr User-Agent LoadBalancer-HealthCheck

  default-server check inter 15s ssl verify required ca-file /etc/ssl/certs/ca-certificates.crt alpn http/1.1

  server nghttp2 nghttp2.org:443
  server nghttp3 nghttp2.org:444

backend tcpchecks

  option tcp-check
  tcp-check send GET\ /status\ HTTP/1.1\r\n\r\b
  tcp-check expect string HTTP/1.1\ 200\ OK

  default-server check inter 15s

  server nghttp2 nghttp2.org:443
  server nghttp3 nghttp2.org:444
